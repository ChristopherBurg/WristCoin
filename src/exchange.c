#include "exchange.h"

ExData * create_ex_data(void) {
  ExData *data = (ExData *) malloc(sizeof(ExData));

  data->ex_name = NULL;
  data->low = 0;
  data->high = 0;
  data->avg = 0;
  data->last = 0;
  data->vol = 0;

  return data;
}

void destroy_ex_data(ExData *data) {
  app_log(APP_LOG_LEVEL_DEBUG, "exchange.c", 17, "destroy_ex_data: Received order to destroying ExData struct %p.", data);
  if (data != NULL) {
    if (data->ex_name != NULL) {
      app_log(APP_LOG_LEVEL_DEBUG, "exchange.c", 20, "destroy_ex_data: Destroying ExData->ex_name %p.", data->ex_name);
      free(data->ex_name);
      data->ex_name = NULL;
    }

    app_log(APP_LOG_LEVEL_DEBUG, "wrist_coin.c", 25, "destroy_ex_data: Destroying ExData struct %p now.", data);
    free(data);
    data = NULL;
    app_log(APP_LOG_LEVEL_DEBUG, "wrist_coin.c", 28, "destroy_ex_data: ExData struct destroyed. Pointer is now %p.", data);
  }
}

void set_ex_name(ExData * data, char *src) {
  if (data->ex_name != NULL) {
    free(data->ex_name);
    data->ex_name = NULL;
  }

  app_log(APP_LOG_LEVEL_DEBUG, "exchange.c", 35, "set_ex_name: Allocating %d bytes for ex_name.", (strlen(src) + 1));
  data->ex_name = (char *) malloc(sizeof(char) * strlen(src) + 1);

  app_log(APP_LOG_LEVEL_DEBUG, "exchange.", 38, "set_ex_name: Copying %s into ex_name.", src);
  strncpy(data->ex_name, src, strlen(src) + 1);

  app_log(APP_LOG_LEVEL_DEBUG, "exchange.c", 41, "set_ex_name: ex_name now contains %s.", data->ex_name);
}


/* TODO: Remove everything below this commend when exchange_details has been
 *       reworked.
 */
void format_as_dollars(char *dest, int32_t value) {
    int32_t characteristic = 0;
    int32_t mantissa = 0;

    /* I know this looks like a lot of malarkey but the Pebble SDK is unable to
       unable to dispaly floating point values using format strings. The
       documentation specifically states that the %e, %f, and %f flags are not
       supported. To get around this limitation I had to jerryrig.

       The following code generates the characteristic (number in front of the
       decimal point) but doing integer division. The last two digits are
       truncated. After that the mantissa (number after the decimal point) is
       generated by subtracting the characteristic * 100 from the stored value.

       Feel free to laugh but it works.
    */
    characteristic = value / 100;
    mantissa = value - (characteristic * 100);
    snprintf(dest, PRICE_FIELD_LENGTH, "$ %ld.%02ld", characteristic, mantissa);
}

/*
void format_as_bitcoin_with_precision(char *dest, int64_t value, uint8_t precision) {
    int64_t characteristic = 0;
    int64_t mantissa = 0;

    // Bitcoin can only be divided down to eight decimal points. Therefore any
    // precision higher than eight is useless.
    if (precision > 8) {
        precision = 8;
    }

    characteristic = value / 100000000;
    mantissa = value - (characteristic * 100000000);
    mantissa = mantissa / (10 ^ (8 - precision));

    snprintf(dest, VOLUME_FIELD_LENGTH, "%lld.%lld", characteristic, mantissa);
}

void format_as_bitcoin(char *dest, int64_t value) {
    format_as_bitcoin_with_precision(dest, value, 8);
}
*/

void format_as_bitcoin(char *dest, int64_t value) {
    int64_t characteristic = 0;
    int64_t mantissa = 0;

    characteristic = value / 100000000;
    mantissa = value - (characteristic * 100000000);

    snprintf(dest, VOLUME_FIELD_LENGTH, "%lld.%08lld", characteristic, mantissa);
}
